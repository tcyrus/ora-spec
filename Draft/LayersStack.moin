##language: en

''This page is part of the [[../|Draft OpenRaster specification]].''

----------------------------------------

Note: this is an early draft of the specification, do not take anything on this page for granted. Pretty much everything is open for discussion.

= Introduction =

This document specifies the [[../|OpenRaster]] Layer Stack XML format. The main two goals of the specification are interoperability between applications and allowing files to be saved without destructive pixel operations.

Note that this document does not define how the data is stored, and especially doesn't address the issue of how to store pixels nor how !OpenRaster files can be stored on disk. This document doesn't address either the mathematics behind layer compositing operations or behind filters. All of this part of the !OpenRaster specification are described in other documents.

The first part of the document explains the concept of a baseline Layer Stack, with examples. Each attribute and element defined by the baseline profile is explained individually.

== Baseline documents ==

A baseline !OpenRaster document is a document that can be opened and look similar on all applications and platforms. The baseline layer stack format defines the minimum requirement to achieve interoperability and what is unsafe for interoperability. Layer Stack format permits extensions, which should be individually specified in detail, and work safely with the baseline profile.

Some users will require full interoperability, to create files which can be edited on every application supporting !OpenRaster. Other users will only need to view !OpenRaster files. This specification defines two classes of baseline support:

 * "Full baseline", which allows reading and editing
 * "Viewing baseline" which guarantees visualization of the file, but editing might damage the result

= Syntax =

The formal syntax of the layer stack is given following the [[http://www.relaxng.org|RelaxNG schema]]:

 * https://gitorious.org/openraster/openraster-standard/blobs/master/schema.rnc (compact format, canonical schema)
 * https://gitorious.org/openraster/openraster-standard/blobs/master/schema.rng (xml format)

= Example =

{{{
<?xml version='1.0' encoding='UTF-8'?>
<image w="300" h="177">
 <stack>
   <stack x="10">
     <filter name="invert" type="invert" />
     <stack>
       <layer name="OpenRaster Logo" src="data/hw.svg" x="5" y="5" />
       <text x="50" y="10">Use a Rich Text XML Specification to write cool text in your OpenRaster File</text>
     </stack>
   </stack>
   <filter name="filter1" type="standard:gaussianblur">
     <params>
       <param name="radius">10</param>
     </params>
     <stack>
       <layer name="mask2" src="data/mask2.data" composite-op="svg:src-over" />
       <layer name="mask1" src="data/mask1.png" />
     </stack>
   </filter>
   <layer name="layer1" src="data/image1.png" />
 </stack>
</image>
}}}

= Elements and Attributes =

== Common attributes ==

 * "{{{x}}}" and "{{{y}}}": position attributes. These are signed integers with a default value of 0.
 * "{{{name}}}": The name of the object represented by an element. A Unicode string, encoded in the XML document's own encoding.

== image element ==

This is the root element of the file. The logical size of the image is given by the mandatory "{{{w}}}" and "{{{h}}}" attributes, which are positive integers. The content expressed within {{{image}}} may have extents which are can be smaller or larger, and so the image should be cropped to (0,0,w,h) when displaying, printing, or otherwise exporting to a context which requires a rectangular image.

== stack element ==

This element describes a group of layers. They may contain sub-{{{stack}}}s, {{{layer}}}s, {{{filter}}}s or {{{text}}}s. The first element in a stack is the uppermost.

== layer element ==

The layer element defines a graphical layer within a layer stack, stored in a separate file within the !OpenRaster file. The following attribute is required:

 * "{{{src}}}": the path to the stored data file for this layer. See the [[../FileLayout|File Layout Specification]] for an explanation of the values which can go here.

Layer elements may have {{{name}}}, {{{x}}} and {{{y}}} attributes, as defined above.

The following attributes are optional:

 * "{{{composite-op}}}": the compositing operation used by this layer.
   * Valid values are the following operations as defined by the [[http://dev.w3.org/SVG/modules/compositing/master/SVGCompositing.html#comp-op-property|SVG 1.2 standard]]
     {{{svg:src-over}}} | {{{svg:plus}}} | {{{svg:multiply}}} | {{{svg:screen}}} | {{{svg:overlay}}} | {{{svg:darken}}} | {{{svg:lighten}}} | {{{svg:color-dodge}}} | {{{svg:color-burn}}} | {{{svg:hard-light}}} | {{{svg:soft-light}}} | {{{svg:difference}}}
   * Default value: {{{svg:src-over}}}. This is the traditional "normal" or "over" operation used for alpha compositing.
   * In the future other compositing modes might be added, and a way for applications to define new modes will be specified.
 * "opacity" a simple floating-point number, between 0.0 for fully transparent and 1.0 for fully opaque.
 * "{{{visibility}}}" : The visibility of this layer.
   * Valid values are either {{{visible}}}, or {{{hidden}}}.
   * Default value: {{{visible}}}.

== filter element ==

This element defines a layer which instead of containing pixel data, applies a filter onto the composited result of the layers below it in the stack. The attributes are:

 * "{{{type}}}": the type of the filter. Type names make use of namespaces, they must have the following form: "namespace:name". Three namespaces are defined:
   * "standard": for the list of filters and the associated mathematics, see the relevant !OpenRaster specification
   * "composite": composite filter are filters which are a composition of a list of standard filters. The name must be the name of a filter defined in the same file.
   * "application": non-standard filters; the name is formed as followed "application:filtername". For example, for an application called !MyGraphApp, the full name is "application:!MyGraphApp:!MyFilter". Use of such a type of filter prevents the file from being a Full Baseline !OpenRaster file; however use of the "{{{output}}}" attribute defined below allows the file to be conformant to the Viewing Baseline.
 * "{{{output}}}": the file name of the data of the filter output, this attribute is only needed when the type of the filter is of the "application" namespace, and if the user wants to create a Viewing Baseline layer stack.

== params element ==

This element is used to describe the parameters used for a filter layer. The standard filters each have a defined list of parameters, defined permissible values. Attributes:

 * "{{{version}}}": correspond to the version of the filter, either the version of the filter specification for standard filter, or any number defined by the application for application-specific filters.

== param element ==

Description of the attributes:

 * "{{{name}}}": the name of the parameter.

The parameter's value is formed by the content of the {{{param}}} element.

For "composite" filters, the params element allows variables to be defined which are then used to parameterise each contained filter. For example, consider a composite function composed of "standard:blur" filter with the parameter "radius" applied with a "standard:invert" filter. It is defined as follows in the composite section:

{{{
<compositefilter name="blurinvert" >
  <filter name="blur">
    <params>
      <param name="radius">
        @R@
      </param>
    </params>
  </filter>
  <filter name="invert" />
</compositefilter>
}}}

Then the usage would be:

{{{
<filter name="composite:blurinvert" >
  <params>
    <param name="R">10</param>
  </params>
</filter>
}}}

TODO: reconsider this, is it useful ? it just come out of my mind that is the only usefull use of parameters for composite filter, but if it's useless, lets not allow any parameters for them !

== text element ==

TODO: define it! Ideally, use another rich text specification, e.g. a relevant subset of the !OpenDocument Text specification or XHTML.
